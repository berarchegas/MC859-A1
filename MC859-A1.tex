\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx} % Required for inserting images

\usepackage[draft]{hyperref}
\usepackage{xspace}

\newcommand{\outDegree}{\ensuremath{\mathit{outDegree}}\xspace}
\newcommand{\inDegree}{\ensuremath{\mathit{inDegree}}\xspace}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage{setspace}
\usepackage{amsthm}

\usepackage{cfr-lm}
\usepackage{microtype}

\newtheorem{lemma}{Lema}[section]

\usepackage{array, makecell, multirow,
            ltablex}            % <--- doesn't change anything, 
                                % however for keep X column features
                                % you should add (before table) \keepXColumns 
\newcolumntype{B}{>{\global\let\currentrowstyle\relax}}
\newcolumntype{^}{>{\currentrowstyle}}
\newcommand{\rowstyle}[1]{\gdef\currentrowstyle{#1}%
                          #1\ignorespaces}
\newcolumntype{C}{>{\centering\arraybackslash}X}   % <-- new
\usepackage{siunitx}

\title{MC$859$ - A$1$}
\author{Andreas Cisi Ramos $246932$ \\
Bernardo Panka Archegas $246970$ \\
Bruno Amaral Teixeira de Freitas $246983$ \\}
\date{}

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=C,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\begin{document}
\doublespacing
\maketitle

\section{Introdução}

Nosso objetivo é relatar o processo do nosso grupo de aplicação da meta heurística do GRASP ao problema MAX-KQBF, que envolve maximizar uma função binária quadrática sob uma restrição de capacidade. O desafio é encontrar um conjunto de variáveis cuja soma dos pesos não exceda um limite dado, enquanto se maximiza o valor da função.

\section{Descrição do Problema}

O problema MAX-KQBF pode ser formalmente descrito como segue: Dada uma capacidade $W \in \mathbb{R}$ e um peso $w_i \in \mathbb{R}$ associado a cada variável $x_i$, deseja-se maximizar uma função binária quadrática sujeita à condição de que a soma dos pesos das variáveis selecionadas não exceda a capacidade $W$. Este problema é uma extensão do clássico problema da mochila, incorporando elementos de interações entre pares de itens através da função binária quadrática.

Esse problema já é NP-difícil mesmo se removermos a restrição de capacidade. Nesse caso, estamos lidando com uma versão ainda mais restrita.

\section{GRASP e nossa implementação}

O GRASP (Greedy Randomized Adaptive Search Procedure) é uma meta-heurística para encontrar soluções aproximadas para problemas de otimização difícil. Nossa implementação do GRASP para o MAX-KQBF consiste em duas fases principais: construção e busca local. Na fase de construção, geramos soluções iniciais de forma gulosa e aleatória, garantindo diversidade enquanto mantemos a qualidade das soluções. Na fase de busca local, refinamos essas soluções explorando seus vizinhos até alcançar um ótimo local. A alternância entre construção gulosa e busca local permite ao GRASP explorar eficientemente o espaço de soluções, balanceando construções aleatórias e determinísticas.

Escrevam o resto aí

\subsection{Fase de construção}

Para essa parte utilizamos três opções de algoritmos: a versão padrão, Greedy Randomized Construction, e dois métodos alternativos, Sampled Greedy Construction e Random Plus Greedy Construction.

Na fase de construção padrão o conjunto de elementos candidatos é formado por todos os elementos do conjunto base que podem ser incorporados à solução parcial sem comprometer a construção de uma solução viável com os elementos restantes. A seleção do próximo elemento é baseada em uma função gulosa que avalia o custo incremental da sua inclusão na solução em construção. Os melhores elementos formam uma lista restrita de candidatos, de onde um é escolhido aleatoriamente para inclusão na solução parcial. Após a escolha, a lista é atualizada e os custos incrementais são recalculados. Esse processo continua até não haver mais candidatos disponíveis.

Para o método alternativo Random Plus Greedy Construction  durante os primeiros \textit{p} passos da construção, o algoritmo introduz aleatoriedade na seleção dos elementos para construir uma solução parcial. Logo, o algoritmo escolhe os elementos candidatos de forma mais aleatória. Após os primeiros \textit{p} passos, o algoritmo muda para uma abordagem puramente gulosa. Nesta fase, a aleatoriedade é eliminada e o algoritmo seleciona os elementos candidatos com base em critérios gulosos, buscando otimizar a solução parcial de forma determinística.Pode-se controlar o equilíbrio entre a parte gulosa e aleatória alterando o valor do parâmetro \textit{p}. Valores maiores de \textit{p} estão associados a soluções mais aleatórias, enquanto valores menores resultam em soluções mais gulosas.

Para o método alterativo Sampled Greedy assim como o método anterior também é  controlado por um parâmetro \textit{p}.Em cada etapa do processo de construção, o algoritmo constrói uma lista de candidatos restritos, amostrando aleatoriamente \textit{p} elementos do conjunto de candidatos C, no caso de \textit{p} ser maior que o número de elementos do conjunto, então todos os elementos do conjunto são selecionados. Cada elemento da lista restrita é avaliado pela função gulosa. O elemento com o menor valor dessa avaliação é adicionado à solução parcial. Esses dois passos são repetidos até que não haja mais elementos candidatos.O equilíbrio entre a parte gulosa e aleatória também pode ser controlado alterando o valor do parâmetro \textit{p}, ou seja, o número de elementos candidatos que são amostrados.



\subsection{Fase de busca local}

Aqui que eu acho que vocês vão ter que codar, achei que minha solução não ficou tão boa pelos resultados que tive.

No momento eu defini vizinhança como qualquer solução que delete no máximo um elemento, essa definição acredito que seja boa. No entanto, depois que eu deleto um elemento, eu estou adicionando elementos até não dar mais baseado no valor inicial, acho que vocês conseguem pensar em algo mais elaborado.

Outra coisa que pensei também é que podemos testar parar de adicionar itens se todos os itens vão adicionar valor negativo. No momento eu sempre adiciono enquanto tem espaço.

\section{Resultados}

Escrevam aqui quais configurações vocês testaram, o que deu certo, o que deu errado, o que teve que ser rodado de novo, etc

Coloquem várias tabelas (vai ocupar bastante espaço já que são 7 instâncias * 5 configurações).


\section{Conclusão}

Escrever uma conclusão baseada nos resultados

\end{document}
